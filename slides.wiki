== Introduction ==

==== Todays Schedule ====

<[block]{Morning}

* Valentin
** Development Methodologies
** Agile Methods
** Unit testing
** Version Control

* Rike
** Unit testing demo
** Subversion demo
** Debugging demo

* Exercise
** Subversion
** Unit Tetsing 

[block]>

==== Todays Schedule ====

<[block]{Afternoon}

* Nico
** Design Principles
** Object Orientation
** Design Patterns

[block]>

==== Outline ====

\tableofcontents[currentsection]

==== Motivation ====

* Many scientists write code regularly but few have formally been trained to do so
* Best practices can make a lot of difference
* Development methodologies are established in the software engineering industry
* We can learn a lot from them to improve our coding skills 

==== Scenarios ====

*  Lone student/scientist

<[figure][ht]
    <<<lucky_luke.jpg, scale=0.30>>>
[figure]>

*  Small team of scientists, working on a common library
*  Speed of development more important than execution speed

*  Often need to try out different ideas quickly:
** rapid prototyping of a proposed algorithm
** re-use/modify existing code

== Agile methods ==

==== Outline ====

\tableofcontents[currentsection]

==== What is a development methodology ====

Consist of:

* A philosophy that governs the style and approach towards development
* A set of tools and models to support the particular approach

Help answer the following questions:

* How far ahead should I plan?
* What should I prioritize?
* When do I write tests and documentation?

==== The waterfall model, Royce 1970 ====

<[figure][ht]
    <<<Waterfall_model.png, scale=0.25>>>
[figure]>

* Iterative process
* But: very heavyweight
* Not efficient or adaptive

\tiny{The image is licensed under the Creative Commons Attribution 3.0 License. (c) Paul Smith}

==== Agile Methods ====

* Agile methods grew out of their iterative predecessors during the late 90's
* Generic name for set of more specific paradigms
* Set of ''best practices''

* Particularly suited for small teams ( less than 10 people) facing  unpredictable or rapidly changing requirements (sounds familiar?)

==== Prominent Features of Agile methods ====

* Minimal planning

* Small development iterations

* Rely heavily on testing

* Promote collaboration and teamwork

* Very adaptive

==== The Basic Agile Workflow ====

* Define test
* Write simplest version of code
* Ensure tests pass
* Write better version of code

==== Example ====

<[block]{Define Test}
function @my\_sum@ should return the sum of a list.
[block]>

<[block]{Simplest version of the code}
<[code][style=basic, language=Python]
def my_sum(l):
    a = 0
    for i in l:
        a = a + i
    return a
[code]>
[block]>

==== Example ====

<[block]{Ensure the test passes}
<[code][style=basic, language=Python]
>>> my_sum(\[1,2,3\]) 
6 
[code]>
[block]>

<[block]{Better version of the code}
<[code][style=basic, language=Python]
def my_sum(my_list):
    return sum(my_list)
[code]>
[block]>

==== Agile methods ====
<[figure][ht]
    <<<dilbert-agile_programming.jpg, scale=0.4>>>
[figure]>


==== Whats Next ====

* Look at tools to support the agile workflow

* Better testing with '''Unit Tests'''

* Keeping track of changes and collaborating with '''Version Control'''

* Additional techniques

== Best Practices ==

=== Unit Testing ===

==== Unit Tests ====

<[block]{Definition of a ''Unit''}
* The smallest testable piece of code
* Example: @my\_sum@
[block]>

* We wish to automate testing of our units
* In python we use the package @unittest@

==== Example ====

<[code][style=basic, language=Python]
import unittest

def my_sum(my_list):
    return sum(my_list)

class Test(unittest.TestCase):
    def test_my_sum(self):
        self.assertEqual(my_sum(\[1,2,3\]),6)

if __name__ == "__main__":
    unittest.main()

[code]>

==== Running the Example ====

<[code][style=basic, language=Python]
% python example-test2.py
.
--------------------------------------------------------
Ran 1 test in 0.000s

OK
[code]>

==== The Basic Agile Workflow - Reloaded ====

* Write unit tests
* Write simplest version of unit
* Ensure all unit tests pass
* Write better version of unit

==== Goals ====

* check code works

* check design works

* catch regression

==== Benefits ====

* Easier to test the whole, if the units work

* Can modify parts, and be sure the rest still works

* Provide examples of how to use code

==== How to test ? ====

* Test with simple (but general) cases, using hard coded solutions
** @sum(3,5) = 5@

* Test general routines with specific ones
** test @polyomial\_expansion(data, degree)@ with @quadratic\_expansion(data)@

* Test special or boundary cases
** test @has\_prefix(string, pfx)@ for @pfx=""@

* Test that meaningful error messages are raised upon corrupt input
** Relevant when writing scientific libraries

(There will be some more concrete example in the second part.)

==== What makes a good test? ====

* independent (of each other, and of user input)

* repeatable (i.e. deterministic)

* self-contained

==== Stuff thats harder to test ====

Probabilistic code
* Use toy examples as validation
* Consider fixing the seed for your pseudo random number generator

Hardware
* use mock up software that behaves like the hardware should

Plots
* (any creative ideas welcome)

==== Test Suits ====

* All unit tests are collected into a test suite

* Execute the entire test suite with a single command

* Can be used to provide reports and statistics

==== Dealing with bugs ====

* Isolate the bug

* Write a unit test to expose the bug

* Fix the code, and ensure the test passes

* Use the test to catch the bug should it reappear

==== Dealing with Bugs ====

<[figure][ht]
    <<<phd_bug.jpg, scale=0.4>>>
[figure]>

==== Introducing new features ====

* Split feature into units

* Use the agile workflow 

* Tests drive the development

* Keep the iterations small 

==== Some last thoughts ====

* Tests increase the confidence that your code works correctly, not only for yourself but also for your reviewers
* Tests are the only way to trust your code
* It might take you a while to get used to the idea, but it will pay off quite rapidly

\hspace{4cm}

* Questions?

=== Version Control ===

==== What is Version Control? ====
<[block]{Problem 1}
"Help my code worked yesterday, but I can't recall what I changed!"
[block]>

<[block]{Problem 2}
"We would like to work together, but we don't know how!"
[block]>

\hspace{6cm}

* Version control is a method to track changes in source code
* Concurrent editing is possible via merging

==== Features ====

* Revert to previous versions

* Document developer effort
** Who changed what, when and why?

* Easy collaboration across the globe

==== What will we use? ====

* Many different systems available

* We will use the de-facto standard:

<[figure][ht]
    <<<Subversion_logo.pdf, scale=0.3>>>
[figure]>

==== Where the versions are stored ====

<[figure][ht]
    <<<centralised.pdf, scale=0.3>>>
[figure]>

* Central server stores all revisions in a '''repository'''
* Developers must connect to this server

==== Contents of the Repository ====

* Each revision consists of:
** Version Number 
** Author
** Message
** Date
** Changes

==== Basic Workflow ====

* Check for updates

* Write code

* Submit to repository

==== Some last thoughts ====

* Use version control for anything thats text
** Code
** Thesis
** Letters

* Again, it might take a while to get used to the idea, but it will pay off rapidly.

===  Other techniques ===

==== Pair Programming ====

* Two developers, one computer
* Two roles: driver and navigator
* Driver sits at keyboard
* Navigator observes and instructs
* Switch roles every so often

==== Optimization ====

* Readable code is usually better than fast code
* Only optimize if its absolutely necessary, seriously
* Only optimize your bottlenecks
* ...and identify these using a profiler

Optimizations Strategies for Scientific Python
* replace for loops with array multiplication
* implement bottlenecks in Cython
* parallelize you application and run it on a cluster

==== Refactoring ====

* Re-organisation of your code without changing its function:
** remove duplicates by creating functions and methods
** break large code blocks into functions
** rename and restructure code to increase readability and reveal intention

* Always refactor one step at a time, and make sure the code still works in between
* Learn how to use refactoring tools to make your life easier
* Do it continuously for maximum effect

==== Coding Style ====

* Adhere to coding conventions (PEP8)
* OR use a consistent style
* Use automated tools to ensure adherence

==== Documentation ====

* When I learnt to program... documentation was of paramount importance
* With concise and clear languages like python this is less so
* Minimum requirement: at least a docstring

==== Other ideas ====

* Use a build system
* If you are unsure how to do something build a prototype to check feasibility
* Use automated testing, and collect statistics
* Use a bug tracker
* Mailinglists and IRC

==== Results ====

* Every scientific result (especially if important) should be independently reproduced at least internally before publication. (German Research Council 1999)

* Increasing pressure to make the source used in publications available

* With unit tested code you need not be embarrassed to publish your code

==== Distributed version control ====

<[figure][ht]
    <<<distributed.pdf, scale=0.19>>>
[figure]>

* Support any workflow ?!


