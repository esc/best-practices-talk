== Introduction ==

==== Introduction ====

* Many scientists write code regularly but few have formally been trained to do so

% you know about variables and loops
% good programs consists of so much more

* '''Best practices''' evolved from programmers folk wisdom
* They increase productivity and decrease stress

* '''Development methodologies''', such as Agile Programming and Test Driven Development, are established in the software engineering industry
* We can learn a lot from them to improve our coding skills

* When programming in Python: Always bear in mind the \\'''Zen of Python'''

% this means stuff that is unique  to python
% these are like mantras, repeat them over and over again

== Best Practices ==

==== Outline ====

\tableofcontents[currentsection]


=== Style and Documentation ===

==== Outline ====

\tableofcontents[currentsection,currentsubsection]

==== Coding Style ====

* Readability counts.
* Explicit is better than implicit.

* Give your variables ''intention revealing'' names
** For example: @numbers@ instead of @nu@
** For example: @numbers@ instead of @list\_of\_float\_numbers@
** See also: \href{ihttp://tottinge.blogsome.com/meaningfulnames/}{Ottingers Rules for Naming}

* Format code to coding conventions
* for example : \href{http://www.python.org/dev/peps/pep-0008/}{PEP-8}
* OR use a consistent style (especially when collaborating)
* Conventions Specify:
** Indentation, maximum line length, blank lines, import, whitespace, comments and variable naming convention

* Use automated tools (aka static checking): \href{http://www.logilab.org/857}{pylint}

==== Documenting Code ====

* Minimum requirement: at least a docstring
* Not only for others, but also for yourself!
* Serves as on-line help in the interpreter

* For a library: document arguments and return objects, including types
* Use the \href{http://projects.scipy.org/numpy/wiki/CodingStyleGuidelines}{numpy docstring conventions}

* Use tools to automatically generate website from docstrings
* For example: \href{http://epydoc.sourceforge.net/}{epydoc} or \href{http://sphinx.pocoo.org/}{sphinx}

* For complex algorithms, document every line, and include equations in docstring

* When your project gets bigger: provide a ''how-to'' or ''quick-start'' on your website

==== Example Docstring ====

\lstinputlisting[style=basic,language=python]{code/my_product_docstring.py}

==== Example Autogenerated Website ====

<[figure]
    <<<images/epydoc.pdf, scale=0.3>>>
[figure]>

=== Unit Tests ===

==== Outline ====

\tableofcontents[currentsection,currentsubsection]

==== Write and Run Unit Tests ====

<[block]{Definition of a ''Unit''}
* The smallest testable piece of code
* Example: @my\_product@
[block]>

* We wish to automate testing of our units
* In python we have several package available:
** \href{http://docs.python.org/library/unittest.html}{unittest}, \href{http://somethingaboutorange.com/mrl/projects/nose/0.11.2/}{nosetest}, \href{http://codespeak.net/py/dist/test/}{pytest}

* Tests increase the confidence that your code works correctly, not only for yourself but also for your reviewers
* Tests are the only way to trust your code
* It might take you a while to get used to writing them, but it will pay off quite rapidly

==== Example ====

\lstinputlisting[style=basic,language=python]{code/my_product_test.py}

\lstinputlisting[style=basic,frame=none]{code/test-output}

==== Goals and Benefits ====

<[block]{Goals}
* check code works
* check design works
* catch regression
[block]>

<[block]{Benefits}
* Easier to test the whole, if the units work
* Can modify parts, and be sure the rest still works
* Provide examples of how to use code
[block]>

* Hands-on exercise tomorrow!

=== Version Control ===

==== Outline ====

\tableofcontents[currentsection,currentsubsection]

==== Motivation to use Version Control ====

<[block]{Problem 1}
"Help!  my code worked yesterday, but I can't recall what I changed."
[block]>

* Version control is a method to track and retrieve modifications in source code

<[block]{Problem 2}
"We would like to work together, but we don't know how!"
[block]>

* Concurrent editing by several developers is possible via merging

==== Features ====

* Checkpoint significant improvements, for example releases

* Document developer effort
** Who changed what, when and why?

* Use version control for anything that's text
** Code
** Thesis/Papers
** Letters

* Easy collaboration across the globe

==== Vocabulary ====

* Modifications to code are called ''commits''
* Commits are stored in a ''repository''

==== Centralised Version Control ====

* All developers connect to a single resource over the network
* Any interaction (history, previous versions, committing) require network access

<[figure]
    <<<images/centralised.pdf, scale=0.25>>>
[figure]>

* Example systems: \href{http://subversion.tigris.org/}{Subversion (svn)}, \href{http://www.cvshome.org/}{Concurrent Version System (cvs)}

==== Distributed Version Control ====

* Several copies of the repository may exist all over the place
* Network access only required when synchronising repositories
* Much more flexible than centralised
* Widely regarded as state-of-the-art
* Example systems: \href{http://git-scm.com/}{git}, \href{http://mercurial.selenic.com/}{Mercurial (hg)}, \href{http://wiki.bazaar.canonical.com/DataStructures}{Bazaar (bzr)}

==== Distributed Supports any Workflow :-) ====

<[figure]
    <<<images/distributed.pdf, scale=0.2>>>
[figure]>


==== What we will use... ====

<[figure]
    <<<images/git.pdf, scale=0.8>>>
[figure]>

* More tomorrow...

=== Refactoring ===

==== Outline ====

\tableofcontents[currentsection,currentsubsection]

==== Refactor Continuously ====

* As a program evolves it may become necessary to rethink earlier decisions and adapt the code accordingly

* Re-organisation of your code without changing its function
* Increase modularity by breaking large code blocks apart
* Rename and restructure code to increase readability and reveal intention

* Always refactor one step at a time, and use the tests to check code still works
* Learn how to use automatic refactoring tools to make your life easier
** For example: \href{http://rope.sourceforge.net/ropeide.html}{ropeide}

* Now is better than never.
* Although never is often better than ''right'' now.

==== Common Refactoring Operations ====

* Rename class/method/module/package/function
* Move class/method/module/package/function
* Encapsulate code in method/function
* Change method/function signature
* Organize imports (remove unused and sort)

* Generally you will improve the readability and modularity of your code
* Usually refactoring will reduce the lines of code

==== Refactoring Example ====

\lstinputlisting[style=basic,language=python]{code/my_product_refactor.py}

=== Do not Repeat Yourself ===

==== Outline ====

\tableofcontents[currentsection,currentsubsection]

==== Do not Repeat Yourself (DRY Principle) ====

* When writing code, avoid duplication

* Categories of Duplication:
** Imposed Duplication
** Inadvertent Duplication
** Impatient Duplication
** Interdeveloper Duplication

* If you detect duplication in code thats already written, refactor mercilessly

==== Imposed Duplication ====

* When duplication seems to be forced on us
* Example: ???

==== Inadvertent Duplication ====

* When duplication happens by accident
* Example: duplication of knowledge
** Variable name: @list\_of\_numbers@ instead of just @numbers@
** Type information duplicated in variable name
** Type information incorrect, function may operate on any sequence such as tuples

==== Impatient Duplication ====

* Quick copy-and-paste, instead of clean refactor
* What happens if the original code contains a bug?
* What happens if the  original code needs to be changed?
* Be patient, invest time now to save time later!

* Example: Using a literal instead of a variable for the program version number

==== Interdeveloper Duplication ====

* Repeated implementation by more than one developer
* Usually concerns utility methods
* Often caused by lack of communication
* Or lack of a module to contain utilities
* Example: product function may already exist in some library

=== Keep it Simple ===

==== Outline ====

\tableofcontents[currentsection,currentsubsection]

==== Keep it Simple (Stupid) (KIS(S) Principle) ====

* Resist the urge to over-engineer
* Write only what you need now

* Simple is better than complex.
* Complex is better than complicated.

* Special cases aren't special enough to break the rules.
* Although practicality beats purity.

== Development Methodologies ==

==== Outline ====

\tableofcontents[currentsection]

=== Definition and Motivation===

==== Outline ====

\tableofcontents[currentsection, currentsubsection]

==== What is a Development Methodology? ====

<[block]{Consist of}
* A philosophy that governs the style and approach towards development
* A set of tools and models to support the particular approach
[block]>

<[block]{Help answer the following questions}
* How far ahead should I plan?
* What should I prioritize?
* When do I write tests and documentation?
[block]>

==== Scenarios ====

*  Lone student/scientist

<[center]
    <<<images/lucky_luke.jpg, scale=0.30>>>
[center]>

*  Small team of scientists, working on a common library
*  Speed of development more important than execution speed

*  Often need to try out different ideas quickly:
** rapid prototyping of a proposed algorithm
** re-use/modify existing code

==== An Example: The Waterfall Model, Royce 1970 ====

<[figure][ht]
    <<<images/waterfall.pdf, scale=0.2>>>
[figure]>

* Sequential software development process
* Originates in the manufacturing and construction industries
* Rigid, inflexible model --- focusing on one stage at a time

=== Agile Methods ===

==== Outline ====

\tableofcontents[currentsection,currentsubsection]

==== Agile Methods ====

* Agile methods emerged during the late 90's
* Generic name for set of more specific paradigms
* Set of ''best practices''

* Particularly suited for:
** Small teams (Fewer than 10 people)
** Unpredictable or rapidly changing requirements

==== Prominent Features of Agile methods ====

* Minimal planning, small development iterations

* Design/implement/test on a modular level

* Rely heavily on testing

* Promote collaboration and teamwork, including frequent input from customer/boss/professor

* Very adaptive, since nothing is set in stone

==== The Agile Spiral ====

<[figure]
    <<<images/agile.pdf, scale=0.2>>>
[figure]>

==== Agile methods ====

<[figure][ht]
    <<<images/dilbert-agile_programming.jpg, scale=0.45>>>
[figure]>

=== Test Driven Development ===

==== Outline ====

\tableofcontents[currentsection,currentsubsection]

==== Test Driven Development (TDD) ====

<[figure]
    <<<images/testdriven.pdf, scale=0.2>>>
[figure]>

* Define unit tests first!
* Develop one unit at a time!

==== Benefits of TDD ====

* Encourages simple designs and inspires confidence

* No one ever ''forgets'' to write the unit tests

* Helps you design a good API, since you are forced to use it when testing

--2em--

* Perhaps you may want to even write the documentation first?

===  Additional techniques ===

==== Outline ====

\tableofcontents[currentsection,currentsubsection]

==== Dealing with Bugs ====

* Isolate the bug using a debugger

* Write a unit test to expose the bug

* Fix the code, and ensure the test passes

* Use the test to catch the bug should it reappear

<[block]{Debugger}
* A program to run your code one step at a time, and giving you the ability to inspect the current state
* For example: \href{http://docs.python.org/library/pdb.html}{pdb}
[block]>

==== Dealing with Bugs ====

<[figure][ht]
    <<<images/phd_bug.jpg, scale=0.45>>>
[figure]>

==== Pair Programming ====

* Two developers, one computer
* Two roles: driver and navigator
* Driver sits at keyboard
* Navigator observes and instructs
* Switch roles every so often

==== Optimization for Speed  --- My Point of View ====

* Readable code is usually better than fast code
* Programmer/Scientist time is more valuable than computer time
* Only optimize if it is absolutely necessary
* Only optimize your bottlenecks
* ...and identify these using a profiler

<[block]{Profiler}
* A tool to measure and provide statistics on the execution time of code.
* For example: \href{http://docs.python.org/library/profile.html}{cProfile}
[block]>

==== Prototyping ====

* If you are unsure how to implement something, write a prototype
* Hack together a proof of concept quickly
* No tests, no documentation, keep it simple
* Use this to explore the feasibility of your idea
* When you are ready, scrap the prototype and start with the unit tests

== Zen of Python ==

==== Outline ====

\tableofcontents[currentsection]

==== The Zen of Python, an Excerpt====[containsverbatim]

<[verbatim]
>>>import this
The Zen of Python, by Tim Peters

Explicit is better than implicit.
Readability counts.
Simple is better than complex.
Complex is better than complicated.
Special cases aren't special enough to break the rules.
Although practicality beats purity.
In the face of ambiguity, refuse the temptation to guess.
Now is better than never.
Although never is often better than *right* now.
[verbatim]>

== Conclusion ==

==== Outline ====

\tableofcontents[currentsection]

==== Results ====

* Every scientific result (especially if important) should be independently reproduced at least internally before publication. (German Research Council 1999)

* Increasing pressure to make the source used in publications available

\hspace{10cm}

* With unit tested code you need not be embarrassed to publish your code

* Using version control allows you to share and collaborate easily

* In this day and age there is '''absolutely no excuse''' to not use them

--2em--

* If you can afford it, hire a developer :-)

==== The Last Slide ====

* Open source tools used to make this presentation:
** \href{http://www-user.tu-chemnitz.de/~mren/wiki2beamer/doku.php}{wiki2beamer}
** \href{http://latex-beamer.sourceforge.net/}{\LaTeX beamer}
** \href{http://projects.gnome.org/dia/}{dia}

\hspace{10cm}

Questions ?

