== Introduction ==

==== Todays Schedule ====

<[bock]{Morning}

* Valentin
** Development Methodologies
** Agile Methods
** Unit testing
** Version Control

* Rike
** Unit testing demo
** Subversion demo
** Debugging demo

* Exercise
** Subversion
** Unit Tetsing 

[block]>

==== Outline ====

\tableofcontents[currentsection]

==== Motivation ====

* Most (Almost All?) scientists write computer programs on a regular basis
* Not many have been trained to do so
* Often its not just about the raw functionality
* Best practices can make a lot of difference
* Development methodologies are established in the software engineer industry
* We can learn a lot from them to improve our coding skills 

==== Scenarios ====

*  Lone student/sceintist
*  Small team of scientists, working on a common library
*  The bottleneck is usually speed of development
*  '''Not''' execution speed

*  Often need to try out different ideas quickly:
** rapid prototyping of a proposed algorithm
** re-use/modify existing code

==== Requirements ====

* Every scientific result (especially if important) should be independently reproduced at least internally before publication. (DFG 1999)
* Hence there must be checks to ensure the code works as advertised

* Increasing pressure for making the source code used in publications available online (especially for theoretical/modelling papers)
* You shouldnâ€™t be embarrassed of publishing your code, more eyes = less bugs
* Your code should be readable and easily reusable (but thats actually quite hard)

== Development methodologies ==

==== Outline ====

\tableofcontents[currentsection]

==== What is a development methodology ====

<[block]{Wikipedia Definition}
refers to the framework that is used to structure, plan, and control the process of developing an information system.
[block]>

Help answer the following questions:

* How far ahead should we plan?
* What should we prioritize?
* When do we write tests and documentation?

Consist of:

* A philosophy that governs the style and approach towards development
* A set of tools and models to support the particular approach

==== The waterfall model, Royce 1970 ====

<[figure][ht]
    <<<Waterfall_model.png, scale=0.25>>>
[figure]>

* Iterative process
* But: very heavyweight
* Not cost efficient

\tiny{This work is licensed under the Creative Commons Attribution 3.0 License. (c) Paul Smith}

==== The spiral model, Beuss 1980 ====

<[figure][ht]
    <<<Spiral_model.png, scale=0.25>>>
[figure]>

* Better, since the iteration cycles are smaller
* Still quite heavyweight and cumbersome

\tiny{This work is public domain. (c) Marc Troy, modified by Wikipedia User Conan.}

==== Xtreme Programming, 1999 Beck, Cunningham, and Jeffries ====

<[figure][ht]
    <<<Xp-loop.png, scale=0.25>>>
[figure]>

* Tight integration cycles
* Very adaptive method
* Relies heavily on testing

\tiny{This work is licensed under the Creative Commons Attribution 3.0 License. (c) Marcel Douwe Dekker}

==== Agile development ====

* Agile methods grew out of their iterative predecessors
* Generic name for set of more specific paradigms
* XP is the most prominent example
* Can be understood as a set of ''best practices''
* Particularly suited for small teams ( less than 10 people) facing  unpredictable or rapidly changing requirements (sounds familiar?)

==== The agile manifesto ====

We are uncovering better ways of developing software by doing it and helping others do it. Through this work we have come to value:

* Individuals and interactions over processes and tools
* Working software over comprehensive documentation
* Customer collaboration over contract negotiation
* Responding to change over following a plan

That is, while there is value in the items on the right, we value the items on the left more.

== Best Practices ==

==== Outline ====

\tableofcontents[currentsection]

==== What should i use? ====

* All agile methods together suggest an overwhelming number of ideas
* In practice you will not use all (even most)
* Experiment to figure out what works for you
* However, some are '''strongly''' recommended, and we will focus on two today:
** Unit Testing
** Version Control
* Its best to adopt these early on, since bad habits will be very hard to break

=== Unit Testing ===

==== Unit Tests ====

* Today, any software without unit tests is considered ''legacy software''
* Tests the ''units'' with a predefined input, to ascertain they return the expected output
* Usually automated so that all unit tests can be executed with a single command

Tests serve to:
* check code works
* check design works
* catch regression

==== Test driven development ====

Make small iterations

* Write the test for a unit first
* Then write the unit itself
* Lastly make sure all tests pass

This should all happen within one coding session, for example an afternoon.


\tiny{(If you can't make this happen, at least write the test after you wrote the code...)}

===== What is a unit? ====

* The smallest possible testable part of an application.
* In python this is a function or method
* Examples:
** function to compute the euclidian distance
** decimal to binary converter
** sort function

==== Benefits of unit tests ====

* Provide additional confidence that your code and design works as intended
* Ease integration testing, since we are confident the individual components work
* Make it much easier to modify the code, and be confident that you didn't break it
* Provide an example of how to use your code to other developers
* If your code is hard to test, this suggests a bad design

==== How to test ? ====

* Test with simple (but general) cases, using hard coded solutions
** @sum(3,5) = 5@

* Test general routines with specific ones
** test @polyomial\_expansion(data, degree)@ with @quadratic\_expansion(data)@

* Test special or boundary cases
** test @has\_prefix(string, pfx)@ for @pfx=""@

* Test that the code raises meaningful errors when wrong data is passed
** Relevant when writing scientific libraries

==== Example of unit tests ====

<[code]
import numpy
import unittest

def euclidian_distance(x, y):
    return numpy.sqrt(sum((x - y)**2))

class TestEuclid(unittest.TestCase):
    def test_scalar(self):
        self.assertEqual(
            euclidian_distance(
            numpy.array(\[2\]), numpy.array(\[3\])),1.0)
    def test_vector(self):
        self.assertEqual(
            euclidian_distance(
            numpy.array(\[2,2\]), numpy.array(\[5,6\])), 5.0)

if __name__ == "__main__":
    unittest.main()
[code]>

==== What makes a good test? ====

* independent (of each other, and of user input)
* repeatable
* self-contained

==== Dealing with bugs ====

* Isolate the bug (preferably with a debugger)
* Write a unit test to expose the bug
* Fix the code, and ensure the test passes
* Use the test to identify if the bug reappears

==== Stuff thats harder to test ====

Probabalistic code
* Use those toy examples as tests
* Test all ''units'' of the algorithm
* Consider fixing the seed for your PRNG

Hardware
* use a mock up that behaves like the hardware should

Plots
* ???


=== Version Control ===

==== What is version control ====

* Toolkit to track modifications of source code

* Two main paradigms
** Centralised
** Distributed

* How often do you ask yourself the question: "Help my code worked yesterday, but i can't recall what i changed!"

==== Benefits of version control ====

* Revert changes without effort
* Document developer effort
* Easy collaboration across the globe
* Synchronisation

==== Centralised version control ====
<[figure][ht]
    <<<centralised.png>>>
[figure]>

==== Distributed version control ====
<[figure][ht]
    <<<centralised.png, scale=0.5>>>
[figure]>
<[figure][ht]
    <<<distributed1.png, scale=0.5>>>
[figure]>
<[figure][ht]
    <<<distributed2.png, scale=0.5>>>
[figure]>

==== What will we use? ====

* Distributed is more flexible
* Centralised has a shallow learning curve
* Hence we will teach you to use the de-fact centralised standard:
* @subversion@

===  Other techniques ===

==== Pair Programming ====

* Two developers, one computer
* Two roles: driver and navigator
* Driver sits at keyboard
* Navigator observers and instructs
* Switch roles every so often

==== Optimization ====

* Readable code is usually better than fast code
* Only optimize if its absolutely necessary, seriously
* Only optimize your bottlenecks
* and identify these using a profiler

Optimizations Strategies for Scientific Python
* replace for loops with arry multiplication
* implement bottlenecks in Cython
* parallelize you application and run it on a cluster

==== Refactoring ====

* Re-organisation of your code without changing its function:
** remove duplicates by creating functions and methods
** break large code blocks into functions
** rename and restructure code to increase readability and reveal intention

* Always refactor one step at a time, and make sure the code still works in between
* Learn how to use refactoring tools to make your life easier
* Do it continously for maximum effect

==== Coding Style ====

* Adhere to coding conventions (PEP8)
* OR use a consisten style
* Use automated tools to ensure adherence

==== Other ideas ====

* Use a build system
* If you are unsure how to do something build a prototype to check feasability
* Use automated testing, and collect statistics
* Use a bug tracker


