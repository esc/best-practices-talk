== Introduction ==

==== Outline ====

\tableofcontents[currentsection]

==== Motivation ====

* Many scientists write code regularly but few have formally been trained to do so
* Best practices can make a lot of difference
* Development methodologies, such as Agile Programming and Test Driven Development, are established in the software engineering industry
* We can learn a lot from them to improve our coding skills
* Always bear in mind the Zen of Python


== Best Practices ==

==== Best Practices ====

* Document your code
* Refactor Continuously
* Do not repeat Yourself (DRY Principle)
* Keep it simple (stupid) (KIS(S) Principle)
* Use Version Control
* Write and run Unit Tests

==== Documenting Code ====

* Minimum requirement: at least a docstring
* These serve as help in the interpreter
* For a library, document arguments and return objects including types
* Use the numpy docstring conventions
* Use tools to automatically generated website from code: '''pydoc''' or '''sphinx'''
* For complicated algorithms, document every line
* When your project gets bigger: provide a how-to or quickstart on your website

==== Example Docstring ====

\lstinputlisting[style=basic,language=python]{my_product_docstring.py}

==== Refactor Continuously ====

This is what it's called when you write a ''better'' version of your code.

* Re-organisation of your code without changing it's function:
** remove duplicates by creating functions and methods
** increase modularity by breaking large code blocks apart
** rename and restructure code to increase readability and reveal intention

* Always refactor one step at a time, and use the unit tests to check code still works
* Learn how to use automatic refactoring tools to make your life easier, for example '''ropeide'''

==== Do not repeat yourself (DRY Principle) ====

* When writing code, avoid duplication

* Categories of Duplication:
** Imposed Duplication
** Inadvertent Duplication
** Impatient Duplication
** Interdeveloper Duplication

* If you detect duplication in code thats already written, refactor mercilessly

==== Imposed Duplication ====

* When duplication seems to be forced on us

==== Inadvertent Duplication ====

* Accidental duplication
* Example: a line class that stores start, end ''and'' length

==== Impatient Duplication ====

* Quick copy-and-paste, instead of clean refactor
* Example: Using a literal instead of a variable for the program version number
* What happens if the original code contains a bug?
* What happens if the  original code needs to be changed?
* Be patient, invest time now to save time later!

==== Interdeveloper Duplication ====

* Repeated implementation by more than one developer
* Usually concerns utility methods
* Often caused by lack of communication
* Or lack of a module to contain utilities
* Example: Manhattan distance between two points

==== Use Version Control ====

==== Write and Run Unit Tests ====

== Agile methods ==

==== Scenarios ====

*  Lone student/scientist

<[center]
    <<<images/lucky_luke.jpg, scale=0.30>>>
[center]>

*  Small team of scientists, working on a common library
*  Speed of development more important than execution speed

*  Often need to try out different ideas quickly:
** rapid prototyping of a proposed algorithm
** re-use/modify existing code

==== What is a Development Methodology ====

Consist of:

* A philosophy that governs the style and approach towards development
* A set of tools and models to support the particular approach

Help answer the following questions:

* How far ahead should I plan?
* What should I prioritize?
* When do I write tests and documentation?

==== The Waterfall Model, Royce 1970 ====

<[figure][ht]
    <<<images/waterfall.pdf, scale=0.25>>>
[figure]>

==== Agile Methods ====

* Agile methods emerged during the late 90's
* Generic name for set of more specific paradigms
* Set of ''best practices''

* Particularly suited for:
** small teams ( less than 10 people)
** unpredictable or rapidly changing requirements

==== Prominent Features of Agile methods ====

* Minimal planning

* Small development iterations

* Rely heavily on testing

* Promote collaboration and teamwork

* Very adaptive

==== The Basic Agile Workflow ====


<[figure]
    <<<images/basic_agile_workflow.pdf, scale=0.25>>>
[figure]>

==== Example ====

<[center]
<<<images/define_test.pdf, scale=0.25>>>

\hspace{10cm}

function @my\_sum@ should return the sum of a list.

[center]>

==== Example ====

<[center]
<<<images/simplest_version.pdf, scale=0.25>>>


\hspace{10cm}

<[code][style=basic, language=Python]
def my_sum(my_list):
    """ Compute sum of list elements. """
    answer = 0
    for item in my_list:
        answer = answer + item
    return answer
[code]>

[center]>

==== Example ====

<[center]
<<<images/ensure_test.pdf, scale=0.25>>>

\hspace{10cm}

<[code][style=basic, language=Python]
>>> my_sum(\[1,2,3\]) 
6 
[code]>

[center]>

==== Example ====

<[center]
<<<images/better_version.pdf, scale=0.25>>>

\hspace{10cm}

<[code][style=basic, language=Python]
def my_sum(my_list):
    """ Compute sum of list elements. """
    return sum(my_list)
[code]>

[center]>

==== Agile methods ====

<[figure][ht]
    <<<images/dilbert-agile_programming.jpg, scale=0.45>>>
[figure]>


==== Whats Next ====

* Look at tools to support the agile workflow

* Better testing with '''Unit Tests'''

* Keeping track of changes and collaborating with '''Version Control'''

* Additional techniques

== Unit Testing ==

==== Outline ====

\tableofcontents[currentsection]


==== Unit Tests ====

<[block]{Definition of a ''Unit''}
* The smallest testable piece of code
* Example: @my\_sum@
[block]>

* We wish to automate testing of our units
* In python we use the package @unittest@

==== Example ====

<[code][style=basic, language=Python, frame=none]
import unittest

def my_sum(my_list):
    """ Compute sum of list elements. """
    return sum(my_list)

class Test(unittest.TestCase):
    def test_my_sum(self):
        self.assertEqual(my_sum(\[1,2,3\]),6)

if __name__ == "__main__":
    unittest.main()

[code]>

==== Running the Example ====

<[code][style=basic,  frame=none]
% python example-test2.py
.
--------------------------------------------------------
Ran 1 test in 0.000s

OK
[code]>

==== The Basic Agile Workflow - Reloaded ====

<[figure]
    <<<images/agile_reloaded.pdf, scale=0.25>>>
[figure]>


==== Goals ====

* check code works

* check design works

* catch regression

==== Benefits ====

* Easier to test the whole, if the units work

* Can modify parts, and be sure the rest still works

* Provide examples of how to use code

==== How to Test ? ====

* Test with simple cases, using hard coded solutions
** @my\_sum([1,2,3]) == 6@

* Test special or boundary cases
** @my\_sum([]) == 0@

* Test that meaningful error messages are raised upon corrupt input
** @my\_sum(['1', 'a'])@ 
** --> @TypeError: unsupported operand type(s) for +: 'int' and 'str'@

==== What Makes a Good Test? ====

* independent (of each other, and of user input)

* repeatable (i.e. deterministic)

* self-contained

==== Stuff That's Harder to Test ====

Probabilistic code
* Use toy examples as validation
* Consider fixing the seed for your pseudo random number generator

Hardware
* use mock up software that behaves like the hardware should

Plots
* (any creative ideas welcome)

==== Test Suits ====

* All unit tests are collected into a test suite

* Execute the entire test suite with a single command

* Can be used to provide reports and statistics

==== Refactoring ====

==== Dealing with Bugs ====

* Isolate the bug (using a debugger)

* Write a unit test to expose the bug

* Fix the code, and ensure the test passes

* Use the test to catch the bug should it reappear

<[block]{Debugger}
A program to run your code one step at a time, and giving you the ability to inspect it's current state. 
[block]>

==== Dealing with Bugs ====

<[figure][ht]
    <<<images/phd_bug.jpg, scale=0.45>>>
[figure]>

==== Introducing New Features ====

* Split feature into units

* Use the agile workflow 

* Tests drive the development

* Keep the iterations small 

==== Some Last Thoughts ====

* Tests increase the confidence that your code works correctly, not only for yourself but also for your reviewers
* Tests are the only way to trust your code
* It might take you a while to get used to the idea, but it will pay off quite rapidly

\hspace{4cm}

* Questions?

== Version Control ==

==== Outline ====

\tableofcontents[currentsection]

==== What is Version Control? ====
<[block]{Problem 1}
"Help my code worked yesterday, but I can't recall what I changed!"
[block]>

<[block]{Problem 2}
"We would like to work together, but we don't know how!"
[block]>

\hspace{6cm}

* Version control is a method to track changes in source code
* Concurrent editing is possible via merging

==== Features ====

* Revert to previous versions

* Document developer effort
** Who changed what, when and why?

* Easy collaboration across the globe

==== Where the Versions are Stored? ====

<[figure][ht]
    <<<images/central.pdf, scale=0.25>>>
[figure]>

* '''repository''' is located on a server
* Developers must connect to this server

==== Contents of the Repository ====

<[figure]
    <<<images/repository.pdf, scale=0.25>>>
[figure]>

==== Basic Version Control Workflow ====

<[figure]
    <<<images/vc_workflow.pdf, scale=0.25>>>
[figure]>

==== What Will We Use ? ====

* Many different systems available

* We will use the de-facto standard:

<[figure][ht]
    <<<images/Subversion_logo.pdf, scale=0.3>>>
[figure]>

==== Some Last Thoughts ====

* Use version control for anything that's text
** Code
** Thesis
** Letters
* We will be using '''centralised''' version control, note there exists also '''decentralised''' version control
* Again, it might take a while to get used to the idea, but it will pay off rapidly.


* Questions

==  Additional techniques ==

==== Outline ====

\tableofcontents[currentsection]

==== Pair Programming ====

* Two developers, one computer
* Two roles: driver and navigator
* Driver sits at keyboard
* Navigator observes and instructs
* Switch roles every so often

==== Optimization for Speed ====

* Readable code is usually better than fast code
* Only optimize if it's absolutely necessary
* Only optimize your bottlenecks
* ...and identify these using a profiler, for example '''cprofile'''

<[block]{Profiler}
A tool to measure and provide statistics on the execution time of code.
[block]>

==== Prototyping ====

* If you are unsure how to implement something, write a prototype
* Hack together a proof of concept quickly
* No tests, no documentation
* Use this to explore the feasability of your idea
* When you are ready, scrap the prototype and start with the unit tests

==== Coding Style ====

* Give your variables meaningful names
* Adhere to coding conventions
* OR use a consistent style
* Use automated tools to ensure adherence: '''pylint'''

==== Results ====

* Every scientific result (especially if important) should be independently reproduced at least internally before publication. (German Research Council 1999)

* Increasing pressure to make the source used in publications available

\hspace{10cm}

* With unit tested code you need not be embarrassed to publish your code

* Using version control allows you to share and collaborate easily

==== The Last Slide ====

* Open source tools used to make this presentation:
** wiki2beamer
** \LaTeX beamer
** dia

\hspace{10cm}

Questions ?

